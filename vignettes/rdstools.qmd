---
title: "Get started with rdstools"
format: html
execute:
  eval: false
vignette: >
  %\VignetteIndexEntry{Get started with rdstools}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

## What is rdstools?

**rdstools** is a lightweight development toolkit for R data science projects. It solves three common pain points:

1. **Console Clutter** - Logs disappear in long-running scripts
2. **IDE Friction** - Repetitive clicks for common operations
3. **Development Overhead** - Boilerplate for testing, coverage, documentation

The package provides three main capabilities:

- **Persistent Logging** - Color-coded console logs with optional file output
- **RStudio Shortcuts** - One-function IDE control for keyboard/Stream Deck mapping
- **Development Helpers** - Coverage reporting, package building, testing wrappers

## A Complete Workflow: Adding Logging to a Shiny App

### Step 1: Install rdstools

```{r}
# From GitHub (development version)
remotes::install_github("r-data-science/rdstools")

# From CRAN (once accepted)
install.packages("rdstools")
```

### Step 2: Open a Log File

At the start of your application, open a log file to capture all messages:

```{r}
library(rdstools)

# Option A: Use temp directory (default)
open_log(fnam = "myapp")
# Creates: /tmp/RtmpXXXX/myapp_TIMESTAMP.log

# Option B: Use specific path
open_log(path = "/var/log/myapp/session.log")

# Option C: Use environment variable (production)
Sys.setenv(RDSTOOLS_LOG_PATH = "/var/log/myapp/prod.log")
open_log()  # Automatically uses env var
```

**Why this helps**: Your logs persist after the session ends, making it possible to:
- Debug issues in deployed applications
- Track user sessions in production
- Audit data processing pipelines
- Share context with support teams

### Step 3: Log During Execution

All `log_*()` functions write to **both** console and file:

```{r}
# Initialize workflow
log_ini("Starting data processing")

# Log progress
log_inf("Loading dataset", add = "Processing 10,000 records")

# Log success
log_suc("Data validation complete", add = "All checks passed")

# Log warnings
log_wrn("Missing values detected", add = "5 records have NA in col_x")

# Log errors (doesn't stop execution)
log_err("Failed to connect to API", add = "Retrying with backup endpoint")

# End workflow
log_end("Processing complete")
```

**Output** (console shows colors, file shows structured format):
```
INI | 2025-12-23 14:30:00 | Starting data processing
INF | 2025-12-23 14:30:05 | Loading dataset | Processing 10,000 records
SUC | 2025-12-23 14:30:12 | Data validation complete | All checks passed
WRN | 2025-12-23 14:30:15 | Missing values detected | 5 records have NA in col_x
ERR | 2025-12-23 14:30:20 | Failed to connect to API | Retrying with backup endpoint
END | 2025-12-23 14:30:25 | Processing complete
```

### Step 4: Read and Analyze Logs

Close the log and retrieve structured data:

```{r}
# Close and gather logs
log_data <- close_log(gather = TRUE)

# Returns a data.table
str(log_data)
# Classes 'data.table' and 'data.frame':  6 obs. of  4 variables:
#  $ level : chr  "INI" "INF" "SUC" "WRN" ...
#  $ timestamp: POSIXct ...
#  $ message: chr  "Starting data processing" ...
#  $ detail : chr  "" "Processing 10,000 records" ...

# Analyze logs
log_data[level == "ERR"]  # Find all errors
log_data[, .N, by = level]  # Count by level
```

**Why gather logs**: Structured log data enables:
- Automated error detection
- Performance analysis (timestamp differences)
- Audit trails for compliance
- Debugging session reconstruction

### Step 5: Resume Logging (Optional)

Reattach to an existing log file:

```{r}
# Check if log is active
log_is_active()  # FALSE

# Reopen the same file
open_log(path = "/var/log/myapp/session.log", append = TRUE)

# Continue logging
log_inf("Session resumed")
```

## Another Workflow: RStudio Productivity

### Keyboard Shortcuts for IDE Control

Map rdstools functions to keyboard shortcuts for instant IDE control:

```{r}
# Activate different panes
activate_terminal()        # Jump to terminal
activate_console()         # Jump to console
activate_source_editor()   # Jump to source

# Change layouts
layout_two_column()   # Standard 2-column
layout_three_column() # 3-column for wide monitors

# Switch themes
switch_theme_dark()   # Random dark theme
switch_theme_light()  # Random light theme

# Development shortcuts
restart_session()       # Restart R (clean slate)
load_all_code()        # devtools::load_all()
document_package()     # devtools::document()
test_package()         # devtools::test()
check_package()        # devtools::check()
pkg_coverage()         # covr::package_coverage()
```

### Setting Up Shortcuts

1. In RStudio: **Tools > Modify Keyboard Shortcuts**
2. Search for "rdstools"
3. Assign key combinations (e.g., `Ctrl+Shift+T` for terminal)
4. Click Apply

**Why this helps**: Eliminates repetitive clicking during development. Common workflows become muscle memory.

## Another Workflow: Debugging with catcall()

When debugging, `catcall()` generates reproducible code to recreate objects:

```{r}
# You're debugging this data.table
DT <- data.table::data.table(
  id = 1:5,
  name = c("Alice", "Bob", "Carol", "Dave", "Eve"),
  value = c(10, NA, 30, 40, 50)
)

# Generate reproducible code
catcall(DT)

# Output (paste into GitHub issue, Slack, etc.):
# data.table::data.table(
#   id = c(1, 2, 3, 4, 5),
#   name = c("Alice", "Bob", "Carol", "Dave", "Eve"),
#   value = c(10, NA, 30, 40, 50)
# )
```

**Why this helps**: When reporting bugs or asking for help, you can share exact data structures instead of vague descriptions. Recipients can run the code immediately without setup.

## Logging Configuration

### Environment Variables

| Variable | Description | Example |
|----------|-------------|---------|
| `RDSTOOLS_LOG_PATH` | Full path to log file | `/var/log/myapp/session.log` |

Set before calling `open_log()` to route all logs to a specific file.

### Options

| Option | Description | Default |
|--------|-------------|---------|
| `rdstools.log_path` | Log file path | NULL |
| `rdstools.log_dir` | Log directory | `tempdir()` |

```{r}
# Set via options
options(rdstools.log_path = "/custom/path/app.log")
open_log()  # Uses the configured path
```

**Precedence order**:
1. `path` argument to `open_log()`
2. `options(rdstools.log_path)`
3. `RDSTOOLS_LOG_PATH` env var
4. `dir` argument to `open_log()`
5. `options(rdstools.log_dir)`
6. `tempdir()` (default)

## When NOT to Use rdstools

**Don't use rdstools when:**

- **Production logging frameworks exist** - Use `log4r`, `logger`, or cloud-native solutions for enterprise apps
- **Structured logging needed** - Use JSON logging with `jsonlite` for machine parsing
- **High-volume logging** - rdstools appends to files; use dedicated log aggregators for thousands of messages/second
- **Non-RStudio environments** - IDE shortcuts require RStudio; skip those functions in other environments

**Do use rdstools when:**

- Developing Shiny apps that need session logs
- Building data pipelines that run in RStudio
- Prototyping and need quick console-to-file logging
- Mapping keyboard shortcuts for package development
- Debugging with reproducible object snapshots

## Next Steps

- **Quickstart**: See `vignette("quickstart")` for hands-on tutorial
- **Advanced Workflow**: See `vignette("advanced-workflow")` for:
  - Log file management in production
  - RStudio addin configuration
  - Stream Deck integration
  - Coverage reporting workflows

## Learn More

- [Function Reference](https://r-data-science.github.io/rdstools/reference/index.html) - Complete API documentation
- [GitHub Repository](https://github.com/r-data-science/rdstools) - Source code and issues
